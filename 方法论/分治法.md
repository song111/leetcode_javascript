## 分治法 ([维基百科](https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95))

在计算机科学中，**分治法**是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“**分而治之**”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

这个技巧是很多高效算法的基础，如**排序算法**（归并排序、快速排序）、**傅立叶变换**（快速傅立叶变换）。

另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以**归纳法**去证明一个理论，为了使**递归**能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。

分治法这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的**折半搜索算法**（或是在数值分析中类似的勘根算法）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用尾部递归的话，便能转换成简单的循环。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用减治法这个名称。

分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。

**早期历史上的先例**
折半搜索算法——一个将原来问题连逐地拆细成大约一半大小的单一子问题的分治算法——拥有一段悠长历史。虽然算法在计算机上的清楚描述出现在 1946 年约翰莫齐利（John Mauchly）的一篇文章里，然而利用已排序的对象序列去加快搜索的构想早已在公元前 200 年的巴比伦尼亚出现。另一个单一子问题的分治算法是找出 2 个数的最大公因数的辗转相除法（透过将数字化小至使子问题变得简单），于公元前数世纪已经出现。

一个早期有多个子问题的分治算法是高斯在 1805 年描述关于快速傅立叶奱换的算法，尽管他没有量化地分析它的操作数目，而快速傅立叶奱换直至在一世纪之后被重新发现之前亦没有广泛流传。这个算法现在称为库利－图基快速傅里叶变换算法。

至于专门用于计算机之上而且正确地分析的分治算法早期例子，则可以数到约翰·冯·诺伊曼于 1945 年发明的归并排序。

另一个显著的例子是 Anatolii Alexeevitch Karatsuba 于 1960 年发明在{\displaystyle O(n^{\log _{2}3})}O(n^{{\log _{2}3}})步骤内将两个 n 位数相乘的 Karatsuba 算法。它反证了安德雷·柯尔莫哥洛夫于 1956 年认为这个乘法需要{\displaystyle \Omega (n^{2})}\Omega (n^{2})步骤的猜想。

高德纳举了一个最初并没有涉及计算机的分治算法例子，就是一般邮局用于分发信件的方法：信件在主要邮局根据不同的地理范围而分到不同的袋里，每个袋亦在运送到地区邮局时分到更小的袋里，如是者直至信件被派发为止。这个方法与早于 1929 年的打孔卡排序机所用的基数排序相类同。

**优势**

- 解决困难问题：分治算法是一个解决复杂问题的好工具，它可以把问题分解成若干个子问题，把子问题逐个解决，再组合到一起形成大问题的答案。比如，汉诺塔问题如果采用分治算法，可以把高度为 n 的塔的问题转换成高度为 n-1 的塔来解决，如此重复，直至问题化简到可以很容易的处理为止。
- 算法效率：人们发现有很多效率很高的分治算法，比如，Karatsuba 快速乘法算法、快速排序算法和并行算法、矩阵乘法的施特拉森算法、快速傅里叶变换等。

**实现**
循环递归
在每一层递归上都有三个步骤：

- 分解：将原问题分解为若干个规模较小，相对独立，与原问题形式相同的子问题。
- 解决：若子问题规模较小且易于解决时，则直接解。否则，递归地解决各子问题。
- 合并：将各子问题的解合并为原问题的解。

**示例**
分治法在高级语言中主要的一个思想是递归，LISP 语言中的体现出了极丰富的分治法。

以下是归并排序 C 语言的示例代码，输入参数中，需要排序的数组为 array[],起始索引为 first，终止索引为 last。调用完成后，array[]中从 first 到 last 处于升序排列。

```c
void merge_sort(int array[], unsigned int first, unsigned int last)
{
int mid = 0;
if(first<last)
{
mid = (first+last)/2;
merge_sort(array, first, mid);
merge_sort(array, mid+1,last);
merge(array,first,mid,last);
}
}
```

在程序中可以看出分治法的应用：在 merge_sort()中，将原来针对索引 first 到 last 的数组排序的问题，分为二份较小的问题

- 先针对索引 first 到 mid 的数组排序。
- 再针对索引 mid+1 到 last 的数组排序。
  最后再进行二个数组的合并。
